<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>汇总python的加密方式 | 张卫宁的技术博客</title>



    <link rel="icon" href="/cat.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">weining&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/E-BOOK">E-BOOK</a>
                
                    <a class="menu-item" href="http://deceptivestarry.gitee.io/finddata">Search</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">weining&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/E-BOOK">E-BOOK</a>
                
                    <a class="menu-item" href="http://deceptivestarry.gitee.io/finddata">Search</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">汇总python的加密方式</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Wenng</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 3, 2018&nbsp;&nbsp;9:11:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Python/">Python</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="python-各种加密"><a href="#python-各种加密" class="headerlink" title="python 各种加密"></a>python 各种加密</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>加密学习<br><strong>对称加密</strong><br>对称密钥加密 ， 又叫私钥加密。即信息发送的方和接受方用一个密钥去加密和揭秘数据。 最大的优势是 加解密速度快，适合对大量数据进行加密， 对称加密的缺点是密钥的管理和分配， 换句话说就是 如何把密钥发送到需要解密你的消息的人手里的问题。在发送密钥的过程中， 密钥有很大的风险被黑客拦截。 现实中的做法是将对称加密的密钥进行非对称加密然后传给需要他的人。<br><strong>非对称加密</strong><br>非对称加密系统， 又称公钥密钥加密。 非对称加密为数据的加密与解密提供了一种非常安全的方式。她使用了一对密钥， 私钥和公钥。 私钥只能有一方安全保管， 不能外泄， 而公钥可以发给任何请求她的人。非对称加密使用这对密钥中的一个进行加密， 而解密却需要一个另外一个密钥。 比如你去银行 你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。 与对称加密的不同之处是， 银行不需要将私钥通过网络发送出去。因此安全性大大提高。 目前最常用的非对称加密算法是RSA算法。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。 公钥机制灵活， 但是加密和解密速度却要比堆成加密慢很多。<br>1） Alice需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。<br>（2） Alice的浏览器向银行的网站请求公钥。<br>（3） 银行将公钥发送给Alice。<br>（4） Alice的浏览器使用银行的公钥将自己的对称密钥加密。<br>（5） Alice的浏览器将加密后的对称密钥发送给银行。<br>（6） 银行使用私钥解密得到Alice浏览器的对称密钥。<br>（7） Alice与银行可以使用对称密钥来对沟通的内容进行加密与解密了。 </p>
<img src="/2018/07/03/a-id-32/70.jpg">

<p>（三）总结<br>（1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。<br>（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。<br>（3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
<h2 id="base64-加密"><a href="#base64-加密" class="headerlink" title="base64 加密"></a>base64 加密</h2><p>python3 输入的都是 二进制 byte类型<br><strong>注意：用于base64编码的，要么是ASCII包含的字符，要么是二进制数据</strong><br>base64 是对称加密</p>
<p>base64 的加密和解密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &apos;hello, world&apos;</span><br><span class="line">s = &quot;你好&quot;</span><br><span class="line"># 加密</span><br><span class="line">bs = base64.b64encode(s.encode(&quot;utf8&quot;))</span><br><span class="line">print(bs)</span><br><span class="line"></span><br><span class="line"># 解密</span><br><span class="line">decode = base64.b64decode(bs)</span><br><span class="line">print(decode)</span><br><span class="line">print(decode.decode(&quot;utf8&quot;))</span><br></pre></td></tr></table></figure>

<p>base64 是 一种用64 个字符来表示任意的二进制数据的方法。base64 可以成为密码学的基石。可以将任意二进制数据进行Base64 编码。 所有的数据都能被编码为并只有64个字符就能表示的文本文件。（ 64字符：A<del>Z a</del>z 0<del>9 + / ）编码后的数据</del>=编码前数据的4/3，会大1/3左右。</p>
<p>Base64编码的原理 </p>
<img src="/2018/07/03/a-id-32/70.jpg">

<p>1 将所有字符转化为ASCII码。<br>2 将ASCII码转化为8位二进制 。<br>3 将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位。<br>4 统一在6位二进制前补两个0凑足8位。<br>5 将补0后的二进制转为十进制。<br>6 从Base64编码表获取十进制对应的Base64编码。</p>
<p><strong>Base64编码的说明</strong></p>
<p>1 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。<br>2 数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>3 不断进行，直到全部输入数据转换完成。<br>4 如果最后剩下两个输入数据，在编码结果后加1个“=”。<br>5 如果最后剩下一个输入数据，编码结果后加2个“=”。<br>6 如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>由于MD5模块在python3中被移除，在python3中使用hashlib模块进行md5操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">str = &quot;我真帅&quot;</span><br><span class="line"></span><br><span class="line"># 创建一个md5 对象</span><br><span class="line">h1 = hashlib.md5()</span><br><span class="line"># 此处必须声明encode</span><br><span class="line"># 若写法为hl.update(str)  报错为： Unicode-objects must be encoded before hashing</span><br><span class="line">h1.update(str.encode())</span><br><span class="line">print(&quot;加密前&quot;, str)</span><br><span class="line">print(&quot;加密后&quot;, h1.hexdigest())</span><br></pre></td></tr></table></figure>

<h2 id="sha1-加密"><a href="#sha1-加密" class="headerlink" title="sha1 加密"></a>sha1 加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def str_encrypt(str):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用sha1加密算法，返回str加密后的字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    sha = hashlib.sha1(str)</span><br><span class="line">    encrypts = sha.hexdigest()</span><br><span class="line">    return encrypts</span><br></pre></td></tr></table></figure>

<p><strong>简介</strong><br>message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。</p>
<p>md5，其实就是一种算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的。</p>
<p><strong>不可逆性</strong><br>每个人都有不同的指纹，看到这个人，可以得出他的指纹等信息，并且唯一对应，但你只看一个指纹，是不可能看到或读到这个人的长相或身份等信息。</p>
<p><strong>特点</strong></p>
<p>1 压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>2 容易计算：从原数据计算出MD5值很容易。<br>3 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</p>
<p><strong>MD5长度</strong></p>
<p>md5的长度，默认为128bit，也就是128个0和1的二进制串。这样表达是很不友好的。所以将二进制转成了16进制，每4个bit表示一个16进制，所以128/4 = 32 换成16进制表示后，为32位了。</p>
<p>为什么网上还有md5是16位的呢？</p>
<p>其实16位的长度，是从32位md5值来的。是将32位md5去掉前八位，去掉后八位得到的。</p>
<p><strong>DES</strong></p>
<p>Python加密库PyCryptodome<br>PyCrytodome 取代了 PyCrypto 。<br>安装与导入<br>Windows安装之前需要先安装Microsoft Visual c++ 2015。</p>
<p>下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=48145" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=48145</a></p>
<p>在Linux上安装，可以使用以下 pip 命令：<br>pip install pycryptodome<br>import Crypto</p>
<p>在Windows 系统上安装则稍有不同：<br>pip install pycryptodomex<br>import Cryptodome</p>
<p>DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准。</p>
<p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。</p>
<p>DES算法的入口参数有三个：Key、Data、Mode。其中Key为7个字节共56位，是DES算法的工作密钥；Data为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。</p>
<p>密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。</p>
<p><strong>加密原理</strong><br>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。</p>
<p><strong>算法步骤</strong><br>1）初始置换<br>其功能是把输入的64位数据块按位重新组合,并把输出分为L0、R0两部分,每部分各长3 2位,其置换规则为将输入的第58位换到第一位,第50位换到第2位……依此类推,最后一位是原来的第7位。L0、R0则是换位输出后的两部分，L0是输出的左32位,R0是右32位,例:设置换前的输入值为D1D2D3……D64,则经过初始置换后的结果为:L0=D58D50……D8;R0=D57D49……D7。<br>其置换规则见下表：<br>58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,<br>62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,<br>57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,<br>61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,<br>2）逆置换<br>经过16次迭代运算后,得到L16、R16,将此作为输入,进行逆置换,逆置换正好是初始置换的逆运算，由此即得到密文输出。<br>此算法是对称加密算法体系中的代表,在计算机网络系统中广泛使用.</p>
<p>加密和解密的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from Cryptodome.Cipher import DES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = b&apos;abcdefgh&apos;  # 密钥 8位或16位,必须为bytes</span><br><span class="line">def pad(text):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 加密函数，如果text不是8的倍数【加密文本text必须为8的倍数！】，那就补足为8的倍数</span><br><span class="line">    :param text:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while len(text) % 8 != 0:</span><br><span class="line">        text += &apos; &apos;</span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">des = DES.new(key, DES.MODE_ECB)  # 创建一个DES实例</span><br><span class="line">text = &apos;Python rocks!&apos;</span><br><span class="line">padded_text = pad(text)</span><br><span class="line">encrypted_text = des.encrypt(padded_text.encode(&apos;utf-8&apos;))  # 加密</span><br><span class="line">print(encrypted_text)</span><br><span class="line"># rstrip(&apos; &apos;)返回从字符串末尾删除所有字符串的字符串(默认空白字符)的副本</span><br><span class="line">plain_text = des.decrypt(encrypted_text).decode().rstrip(&apos; &apos;)  # 解密</span><br><span class="line">print(plain_text)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from Cryptodome.Cipher import DES</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"># 这是密钥</span><br><span class="line">key = b&apos;abcdefgh&apos;</span><br><span class="line"># 需要去生成一个DES对象</span><br><span class="line">des = DES.new(key, DES.MODE_ECB)</span><br><span class="line"># 需要加密的数据</span><br><span class="line">text = &apos;python spider!&apos;</span><br><span class="line">text = text + (8 - (len(text) % 8)) * &apos;=&apos;</span><br><span class="line"># 加密的过程</span><br><span class="line">encrypto_text = des.encrypt(text.encode())</span><br><span class="line"># 加密过后二进制转化为ASCII </span><br><span class="line">encrypto_text = binascii.b2a_hex(encrypto_text)</span><br><span class="line">print(encrypto_text)</span><br><span class="line"># 解密需要ASCII 先转化为二进制 然后再进行解密</span><br><span class="line">plaint = des.decrypt(binascii.a2b_hex(encrypto_text))</span><br><span class="line">print(plaint)</span><br></pre></td></tr></table></figure>

<p><strong>3DES</strong><br>简介</p>
<p>3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。</p>
<p>由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解。3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p>
<p>3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），加密算法，其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，C代表密文，这样：</p>
<p>3DES加密过程为：C=Ek3(Dk2(Ek1(M)))</p>
<p>3DES解密过程为：M=Dk1(EK2(Dk3(C)))</p>
<p><strong>AES</strong><br><strong>简介</strong></p>
<p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<p>AES在软件及硬件上都能快速地加解密，相对来说较易于实作，且只需要很少的存储器。作为一个新的加密标准，目前正被部署应用到更广大的范围。<br>特点与思想</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抵抗所有已知的攻击。</span><br><span class="line">在多个平台上速度快，编码紧凑。</span><br><span class="line">设计简单。</span><br></pre></td></tr></table></figure>

<img src="/2018/07/03/a-id-32/701.jpg">

<p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同。</p>
<p>一般常用的是128位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from Cryptodome.Cipher import AES</span><br><span class="line">from Cryptodome import Random</span><br><span class="line"></span><br><span class="line">from binascii import a2b_hex</span><br><span class="line"></span><br><span class="line"># 要加密的明文</span><br><span class="line">data = &apos;南来北往&apos;</span><br><span class="line"># 密钥key必须为 16（AES-128）， 24（AES-192）， 32（AES-256）</span><br><span class="line">key = b&apos;this is a 16 key&apos;</span><br><span class="line"># 生成长度等于AES 块大小的不可重复的密钥向量</span><br><span class="line">iv = Random.new().read(AES.block_size)</span><br><span class="line">print(iv)</span><br><span class="line"># 使用 key 和iv 初始化AES 对象， 使用MODE_CFB模式</span><br><span class="line">mycipher = AES.new(key, AES.MODE_CFB, iv)</span><br><span class="line">print(mycipher)</span><br><span class="line"># 加密的明文长度必须为16的倍数， 如果长度不为16的倍数， 则需要补足为16的倍数</span><br><span class="line"># 将iv(密钥向量)加到加密的密钥开头， 一起传输</span><br><span class="line">ciptext = iv + mycipher.encrypt(data.encode())</span><br><span class="line"># 解密的话需要用key 和iv 生成的AES对象</span><br><span class="line">print(ciptext)</span><br><span class="line">mydecrypt = AES.new(key, AES.MODE_CFB, ciptext[:16])</span><br><span class="line"># 使用新生成的AES 对象， 将加密的密钥解密</span><br><span class="line">decrytext = mydecrypt.decrypt(ciptext[16:])</span><br><span class="line"></span><br><span class="line">print(decrytext.decode())</span><br></pre></td></tr></table></figure>

<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>非对称加密<br>典型的非对称加密<br>典型的如RSA等，常见方法，使用openssl ,keytools等工具生成一对公私钥对，使用被公钥加密的数据可以使用私钥来解密，反之亦然（被私钥加密的数据也可以被公钥解密) 。</p>
<p>在实际使用中私钥一般保存在发布者手中，是私有的不对外公开的，只将公钥对外公布，就能实现只有私钥的持有者才能将数据解密的方法。 这种加密方式安全系数很高，因为它不用将解密的密钥进行传递，从而没有密钥在传递过程中被截获的风险，而破解密文几乎又是不可能的。</p>
<p>但是算法的效率低，所以常用于很重要数据的加密，常和对称配合使用，使用非对称加密的密钥去加密对称加密的密钥。</p>
<p><strong>简介</strong><br>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。</p>
<p>该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用</p>
<p>而且，因为RSA加密算法的特性，RSA的公钥私钥都是10进制的，但公钥的值常常保存为16进制的格式，所以需要将其用int()方法转换为10进制格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rsa加密</span><br><span class="line">def rsaEncrypt(str):</span><br><span class="line">    # 生成公钥、私钥</span><br><span class="line">    (pubkey, privkey) = rsa.newkeys(512)</span><br><span class="line">    print(&quot;pub: &quot;, pubkey)</span><br><span class="line">    print(&quot;priv: &quot;, privkey)</span><br><span class="line">    # 明文编码格式</span><br><span class="line">    content = str.encode(&apos;utf-8&apos;)</span><br><span class="line">    # 公钥加密</span><br><span class="line">    crypto = rsa.encrypt(content, pubkey)</span><br><span class="line">    return (crypto, privkey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rsa解密</span><br><span class="line">def rsaDecrypt(str, pk):</span><br><span class="line">    # 私钥解密</span><br><span class="line">    content = rsa.decrypt(str, pk)</span><br><span class="line">    con = content.decode(&apos;utf-8&apos;)</span><br><span class="line">    return con</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(a, b) = rsaEncrypt(&quot;hello&quot;)</span><br><span class="line">print(&apos;加密后密文：&apos;)</span><br><span class="line">print(a)</span><br><span class="line">content = rsaDecrypt(a, b)</span><br><span class="line">print(&apos;解密后明文：&apos;)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">def rsa_encrypt(rsa_n, rsa_e, message):</span><br><span class="line">    key = rsa.PublicKey(rsa_n, rsa_e)</span><br><span class="line">    message = rsa.encrypt(message.encode(), key)</span><br><span class="line">    message = binascii.b2a_hex(message)</span><br><span class="line">    return message.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pubkey_n = &apos;8d7e6949d411ce14d7d233d7160f5b2cc753930caba4d5ad24f923a505253b9c39b09a059732250e56c594d735077cfcb0c3508e9f544f101bdf7e97fe1b0d97f273468264b8b24caaa2a90cd9708a417c51cf8ba35444d37c514a0490441a773ccb121034f29748763c6c4f76eb0303559c57071fd89234d140c8bb965f9725&apos;</span><br><span class="line">pubkey_e = &apos;10001&apos;</span><br><span class="line">rsa_n = int(pubkey_n, 16)</span><br><span class="line">rsa_e = int(pubkey_e, 16)</span><br><span class="line">message = &apos;南北今天很忙&apos;</span><br><span class="line">print(&quot;公钥n值长度：&quot;, len(pubkey_n))</span><br><span class="line"></span><br><span class="line">aa = rsa_encrypt(rsa_n, rsa_e, message)</span><br><span class="line">print(aa)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">RSA算法</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">from Cryptodome.PublicKey import RSA</span><br><span class="line"></span><br><span class="line">from Cryptodome.Cipher import PKCS1_OAEP, PKCS1_v1_5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyRSA():</span><br><span class="line">    def create_rsa_key(self, password):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        创建RSA密钥</span><br><span class="line"></span><br><span class="line">        步骤说明：</span><br><span class="line"></span><br><span class="line">        1、从 Crypto.PublicKey 包中导入 RSA，创建一个密码</span><br><span class="line"></span><br><span class="line">        2、生成 1024/2048 位的 RSA 密钥</span><br><span class="line"></span><br><span class="line">        3、调用 RSA 密钥实例的 exportKey 方法，传入密码、使用的 PKCS 标准以及加密方案这三个参数。</span><br><span class="line"></span><br><span class="line">        4、将私钥写入磁盘的文件。</span><br><span class="line"></span><br><span class="line">        5、使用方法链调用 publickey 和 exportKey 方法生成公钥，写入磁盘上的文件。</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        key = RSA.generate(1024)</span><br><span class="line"></span><br><span class="line">        encrypted_key = key.exportKey(passphrase=password.encode(&quot;utf-8&quot;), pkcs=8,</span><br><span class="line"></span><br><span class="line">                                      protection=&quot;scryptAndAES128-CBC&quot;)</span><br><span class="line"></span><br><span class="line">        with open(&quot;my_private_rsa_key.bin&quot;, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(encrypted_key)</span><br><span class="line"></span><br><span class="line">        with open(&quot;my_rsa_public.pem&quot;, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(key.publickey().exportKey())</span><br><span class="line"></span><br><span class="line">    def encrypt(self, plaintext):</span><br><span class="line">        # 加载公钥</span><br><span class="line"></span><br><span class="line">        recipient_key = RSA.import_key(</span><br><span class="line"></span><br><span class="line">            open(&quot;my_rsa_public.pem&quot;).read()</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        cipher_rsa = PKCS1_v1_5.new(recipient_key)</span><br><span class="line"></span><br><span class="line">        en_data = cipher_rsa.encrypt(plaintext.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">        return en_data</span><br><span class="line"></span><br><span class="line">        # print(len(en_data), en_data)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, en_data, password):</span><br><span class="line">        # 读取密钥</span><br><span class="line"></span><br><span class="line">        private_key = RSA.import_key(</span><br><span class="line"></span><br><span class="line">            open(&quot;my_private_rsa_key.bin&quot;).read(),</span><br><span class="line"></span><br><span class="line">            passphrase=password</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        cipher_rsa = PKCS1_v1_5.new(private_key)</span><br><span class="line"></span><br><span class="line">        data = cipher_rsa.decrypt(en_data, None)</span><br><span class="line"></span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">        # print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mrsa = MyRSA()</span><br><span class="line"></span><br><span class="line">mrsa.create_rsa_key(&apos;123456&apos;)</span><br><span class="line"></span><br><span class="line">e = mrsa.encrypt(&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">d = mrsa.decrypt(e, &apos;123456&apos;)</span><br><span class="line"></span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<p>用python实现调用接口的示例代码，过程涉及到很多的加密算法，值得分享一下。<br>首先公钥和私钥如何生成，并且能兼容java平台，尝试了很多方法。最终决定用openssl命令前提，需要安装openssl,Crypto库生成公钥私钥对过程：生成私钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rsa_private_key.pem 1024</span><br></pre></td></tr></table></figure>

<p>根据私钥生成公钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout</span><br></pre></td></tr></table></figure>

<p>这时候的私钥还不能直接被使用，需要进行PKCS#8编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt</span><br></pre></td></tr></table></figure>

<p>  命令中指明了输入私钥文件为rsa_private_key.pem，输出私钥文件为pkcs8_rsa_private_key.pem，不采用任何二次加密（-nocrypt）<br>这时候就获得了一对公钥和私钥，只要拿到对方的公钥，用自己的公钥的格式替换就可以使用啦~~ </p>
<p>我们最好把全局变量给提出来，便于管理。这样子就不用改代码都改一遍了</p>
<p>文件Gl.py</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!-*- coding:utf-8 -*- </span></span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">Created on 2013-6-15 </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">@author: shangwei </span></span><br><span class="line"><span class="string">'''</span> </span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">全局变量 </span></span><br><span class="line"><span class="string">'''</span> </span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA </span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">publickey为对方的公钥 </span></span><br><span class="line"><span class="string">privatekey为商户自己的私钥 </span></span><br><span class="line"><span class="string">'''</span> </span><br><span class="line">publickey = RSA.importKey(open(<span class="string">'rsa_public_key.pem'</span>,<span class="string">'r'</span>).read()) </span><br><span class="line">privatekey=RSA.importKey(open(<span class="string">'pkcs8_rsa_private_key.pem'</span>,<span class="string">'r'</span>).read()) </span><br><span class="line">merchantaccount=<span class="string">'YB010000000xx'</span> </span><br><span class="line">URL=<span class="string">'xxx.xxx.com'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!-*- coding:utf-8 -*- </span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">    Created on 2013-5-24 </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    @author: shangwei </span></span><br><span class="line"><span class="string">    '''</span> </span><br><span class="line">    <span class="keyword">from</span> Crypto <span class="keyword">import</span> Random </span><br><span class="line">    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 </span><br><span class="line">    <span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA </span><br><span class="line">    <span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1 </span><br><span class="line">    <span class="keyword">from</span> rsa <span class="keyword">import</span> key, common, encrypt </span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlencode </span><br><span class="line">    <span class="keyword">import</span> base64 </span><br><span class="line">    <span class="keyword">import</span> hmac </span><br><span class="line">    <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA </span><br><span class="line">    <span class="keyword">import</span> urllib </span><br><span class="line">    <span class="keyword">import</span> urllib2 </span><br><span class="line">    <span class="keyword">import</span> time </span><br><span class="line">    <span class="keyword">import</span> json </span><br><span class="line">    <span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> pk </span><br><span class="line">    <span class="keyword">import</span> Gl </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MerchantAPI</span>:</span> </span><br><span class="line">          </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">doPost</span><span class="params">(self,url,values)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            post请求 </span></span><br><span class="line"><span class="string">            参数URL </span></span><br><span class="line"><span class="string">            字典类型的参数 </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            req = urllib2.Request(url) </span><br><span class="line">            data = urllib.urlencode(values) </span><br><span class="line">            res = urllib2.urlopen(req, data) </span><br><span class="line">            ret = res.read() </span><br><span class="line">            <span class="keyword">return</span> ret </span><br><span class="line">      </span><br><span class="line">          </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">doGet</span><span class="params">(self,url,values)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            get请求 </span></span><br><span class="line"><span class="string">            参数URL </span></span><br><span class="line"><span class="string">            字典类型的参数 </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            REQUEST = url + <span class="string">"?"</span> + urllib.urlencode(values) </span><br><span class="line">            ret = urllib2.urlopen(REQUEST).read() </span><br><span class="line">            <span class="keyword">return</span> ret </span><br><span class="line">            </span><br><span class="line"><span class="meta">        @staticmethod </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_pkcs7padding</span><span class="params">(data)</span>:</span> </span><br><span class="line">            <span class="string">""" </span></span><br><span class="line"><span class="string">            对齐块 </span></span><br><span class="line"><span class="string">            size 16 </span></span><br><span class="line"><span class="string">            999999999=&gt;9999999997777777 </span></span><br><span class="line"><span class="string">            """</span> </span><br><span class="line">            size = AES.block_size </span><br><span class="line">            count = size - len(data)%size </span><br><span class="line">            <span class="keyword">if</span> count: </span><br><span class="line">                data+=(chr(count)*count) </span><br><span class="line">            <span class="keyword">return</span> data </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line"><span class="meta">        @staticmethod </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_depkcs7padding</span><span class="params">(data)</span>:</span> </span><br><span class="line">            <span class="string">""" </span></span><br><span class="line"><span class="string">            反对齐 </span></span><br><span class="line"><span class="string">            """</span> </span><br><span class="line">            newdata = <span class="string">''</span> </span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> data: </span><br><span class="line">                <span class="keyword">if</span> ord(c) &gt; AES.block_size: </span><br><span class="line">                    newdata+=c </span><br><span class="line">            <span class="keyword">return</span> newdata </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        aes加密base64编码 </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">aes_base64_encrypt</span><span class="params">(self,data,key)</span>:</span> </span><br><span class="line">              </span><br><span class="line">            <span class="string">""" </span></span><br><span class="line"><span class="string">            @summary: </span></span><br><span class="line"><span class="string">                1. pkcs7padding </span></span><br><span class="line"><span class="string">                2. aes encrypt </span></span><br><span class="line"><span class="string">                3. base64 encrypt </span></span><br><span class="line"><span class="string">            @return: </span></span><br><span class="line"><span class="string">                string </span></span><br><span class="line"><span class="string">            """</span> </span><br><span class="line">            cipher = AES.new(key) </span><br><span class="line">            <span class="keyword">return</span> base64.b64encode(cipher.encrypt(self._pkcs7padding(data))) </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">base64_aes_decrypt</span><span class="params">(self,data,key)</span>:</span> </span><br><span class="line">            <span class="string">""" </span></span><br><span class="line"><span class="string">            1. base64 decode </span></span><br><span class="line"><span class="string">            2. aes decode </span></span><br><span class="line"><span class="string">            3. dpkcs7padding </span></span><br><span class="line"><span class="string">            """</span> </span><br><span class="line">            cipher = AES.new(key) </span><br><span class="line">            <span class="keyword">return</span> self._depkcs7padding(cipher.decrypt(base64.b64decode(data))) </span><br><span class="line">              </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        rsa加密 </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rsa_base64_encrypt</span><span class="params">(self,data,key)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            1. rsa encrypt </span></span><br><span class="line"><span class="string">            2. base64 encrypt </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            cipher = PKCS1_v1_5.new(key) </span><br><span class="line">            <span class="keyword">return</span> base64.b64encode(cipher.encrypt(data)) </span><br><span class="line">          </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        rsa解密 </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rsa_base64_decrypt</span><span class="params">(self,data,key)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            1. base64 decrypt </span></span><br><span class="line"><span class="string">            2. rsa decrypt </span></span><br><span class="line"><span class="string">            示例代码 </span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">           key = RSA.importKey(open('privkey.der').read()) </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; dsize = SHA.digest_size </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; sentinel = Random.new().read(15+dsize) # Let's assume that average data length is 15 </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; cipher = PKCS1_v1_5.new(key) </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; message = cipher.decrypt(ciphertext, sentinel) </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; digest = SHA.new(message[:-dsize]).digest() </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; if digest==message[-dsize:]: # Note how we DO NOT look for the sentinel </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; print "Encryption was correct." </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; else: </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; print "Encryption was not correct." </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            cipher = PKCS1_v1_5.new(key) </span><br><span class="line">            <span class="keyword">return</span> cipher.decrypt(base64.b64decode(data), Random.new().read(<span class="number">15</span>+SHA.digest_size)) </span><br><span class="line">              </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        RSA签名 </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self,signdata)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            @param signdata: 需要签名的字符串 </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">              </span><br><span class="line">            h=SHA.new(signdata) </span><br><span class="line">            signer = pk.new(Gl.privatekey) </span><br><span class="line">            signn=signer.sign(h) </span><br><span class="line">            signn=base64.b64encode(signn) </span><br><span class="line">            <span class="keyword">return</span> signn </span><br><span class="line">             </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        RSA验签 </span></span><br><span class="line"><span class="string">        结果：如果验签通过，则返回The signature is authentic </span></span><br><span class="line"><span class="string">             如果验签不通过，则返回"The signature is not authentic." </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checksign</span><span class="params">(self,rdata)</span>:</span> </span><br><span class="line">              </span><br><span class="line">            signn=base64.b64decode(rdata.pop(<span class="string">'sign'</span>)) </span><br><span class="line">            signdata=self.sort(rdata) </span><br><span class="line">            verifier = pk.new(Gl.publickey) </span><br><span class="line">            <span class="keyword">if</span> verifier.verify(SHA.new(signdata), signn): </span><br><span class="line">                <span class="keyword">print</span> <span class="string">"The signature is authentic."</span> </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">print</span> <span class="string">"The signature is not authentic."</span> </span><br><span class="line">               </span><br><span class="line">          </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">          </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self,mes)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            作用类似与java的treemap, </span></span><br><span class="line"><span class="string">            取出key值,按照字母排序后将value拼接起来 </span></span><br><span class="line"><span class="string">            返回字符串 </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            _par = [] </span><br><span class="line">             </span><br><span class="line">            keys=mes.keys() </span><br><span class="line">            keys.sort() </span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> keys: </span><br><span class="line">                _par.append(str(mes[v])) </span><br><span class="line">            sep=<span class="string">''</span> </span><br><span class="line">            message=sep.join(_par) </span><br><span class="line">            <span class="keyword">return</span> message </span><br><span class="line">          </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        请求接口前的加密过程 </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">requestprocess</span><span class="params">(self,mesdata)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            加密过程： </span></span><br><span class="line"><span class="string">            1、将需要的参数mes取出key排序后取出value拼成字符串signdata </span></span><br><span class="line"><span class="string">            2、用signdata对商户私钥进行rsa签名，生成签名signn，并转base64格式 </span></span><br><span class="line"><span class="string">            3、将签名signn插入到mesdata的最后生成新的data </span></span><br><span class="line"><span class="string">            4、用encryptkey16位常量对data进行AES加密后转BASE64,生成机密后的data </span></span><br><span class="line"><span class="string">            5、用对方公钥publickey对encryptkey16位常量进行RSA加密BASE64编码，生成加密后的encryptkey </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            signdata=self.sort(mesdata) </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'需要签名的排序后的字符串为：'</span>+signdata </span><br><span class="line">            signn=self.sign(signdata) </span><br><span class="line">      </span><br><span class="line">                </span><br><span class="line">            mesdata[<span class="string">'sign'</span>]=signn </span><br><span class="line">            <span class="keyword">print</span> mesdata </span><br><span class="line">            encryptkey = <span class="string">'1234567890123456'</span> </span><br><span class="line">            data=self.aes_base64_encrypt(json.dumps(mesdata),encryptkey) </span><br><span class="line">          </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'加密后的data='</span>+data </span><br><span class="line">            values=&#123;&#125; </span><br><span class="line">            values[<span class="string">'merchantaccount'</span>]=Gl.merchantaccount </span><br><span class="line">            values[<span class="string">'data'</span>]=data </span><br><span class="line">            values[<span class="string">'encryptkey'</span>]=self.rsa_base64_encrypt(encryptkey,Gl.publickey) </span><br><span class="line">            <span class="keyword">return</span> values </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">        对返回结果进行解密后输出 </span></span><br><span class="line"><span class="string">        '''</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">result_decrypt</span><span class="params">(self,result)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            1、返回的结果json传给data和encryptkey两部分，都为加密后的 </span></span><br><span class="line"><span class="string">            2、用商户私钥对encryptkey进行RSA解密，生成解密后的encryptkey。参考方法：rsa_base64_decrypt </span></span><br><span class="line"><span class="string">            3、用解密后的encryptkey对data进行AES解密。参考方法：base64_aes_decrypt </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            result=json.loads(result) </span><br><span class="line">            kdata=result[<span class="string">'data'</span>] </span><br><span class="line">            kencryptkey=result[<span class="string">'encryptkey'</span>] </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'返回的加密后的data='</span>+kdata </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'返回的加密后的encryptkey='</span>+kencryptkey </span><br><span class="line">            cryptkey=self.rsa_base64_decrypt(kencryptkey,Gl.privatekey) </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'解密后的encryptkey='</span>+cryptkey </span><br><span class="line">            rdata=self.base64_aes_decrypt(kdata,cryptkey) </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'解密后的data='</span>+rdata </span><br><span class="line">            <span class="keyword">return</span> rdata </span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">testCreditPayAsync</span><span class="params">(self)</span>:</span> </span><br><span class="line">            <span class="string">''' </span></span><br><span class="line"><span class="string">            生成公钥私钥对过程： </span></span><br><span class="line"><span class="string">            生成私钥：openssl genrsa -out rsa_private_key.pem 1024 </span></span><br><span class="line"><span class="string">            根据私钥生成公钥： openssl rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout </span></span><br><span class="line"><span class="string">            这时候的私钥还不能直接被使用，需要进行PKCS#8编码： </span></span><br><span class="line"><span class="string">            openssl pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt </span></span><br><span class="line"><span class="string">            命令中指明了输入私钥文件为rsa_private_key.pem，输出私钥文件为pkcs8_rsa_private_key.pem，不采用任何二次加密（-nocrypt） </span></span><br><span class="line"><span class="string">            加密过程： </span></span><br><span class="line"><span class="string">            1、将需要的参数mes取出key排序后取出value拼成字符串signdata </span></span><br><span class="line"><span class="string">            2、用signdata对商户私钥进行rsa签名，生成签名signn，并转base64格式 </span></span><br><span class="line"><span class="string">            3、将签名signn插入到mes的最后生成新的data </span></span><br><span class="line"><span class="string">            4、用encryptkey16位常量对data进行AES加密后转BASE64,生成机密后的data </span></span><br><span class="line"><span class="string">            5、用对方公钥publickey对encryptkey16位常量进行RSA加密BASE64编码，生成加密后的encryptkey </span></span><br><span class="line"><span class="string">            6、将merchantaccount，第四部加密后的data，第五步加密后的encryptkey作为参数post请求给URL http://xxxx/xxx/api/xxx/xxx/xxx/xxx </span></span><br><span class="line"><span class="string">            7、返回的结果json传给data和encryptkey两部分，都为加密后的 </span></span><br><span class="line"><span class="string">            8、用商户私钥对encryptkey进行RSA解密，生成解密后的encryptkey。参考方法：rsa_base64_decrypt </span></span><br><span class="line"><span class="string">            9、用解密后的encryptkey对data进行AES解密。参考方法：base64_aes_decrypt </span></span><br><span class="line"><span class="string">            '''</span> </span><br><span class="line">            transtime=int(time.time()) </span><br><span class="line">            od=str(random.randint(<span class="number">10</span>, <span class="number">100000</span>)) </span><br><span class="line">            mesdata=&#123;<span class="string">"merchantaccount"</span>:Gl.merchantaccount,<span class="string">"cardno"</span>:<span class="string">"xxxx758xxxx23xxxx"</span>,<span class="string">"validthru"</span>:<span class="string">"04xx"</span>,<span class="string">"cvv2"</span>:<span class="string">"200"</span>,<span class="string">"phone"</span>:<span class="string">"1581xxxxxxx"</span>, </span><br><span class="line">    <span class="string">"orderid"</span>:<span class="string">"33hhkssseef3u"</span>+od,<span class="string">"transtime"</span>:transtime,<span class="string">"currency"</span>:<span class="number">156</span>,<span class="string">"amount"</span>:<span class="number">2</span>,<span class="string">"productcatalog"</span>:<span class="string">"1"</span>,<span class="string">"productname"</span>:<span class="string">""</span>,<span class="string">"productdesc"</span>:<span class="string">""</span>, </span><br><span class="line">    <span class="string">"userip"</span>:<span class="string">"192.168.5.251"</span>,<span class="string">"identityid"</span>:<span class="string">"ee"</span>,<span class="string">"identitytype"</span>:<span class="number">6</span>,<span class="string">"other"</span>:<span class="string">""</span>,<span class="string">"callbackurl"</span>:<span class="string">"http://IP/webtest/callback.do"</span>&#125; </span><br><span class="line">            values=self.requestprocess(mesdata) </span><br><span class="line">            url=<span class="string">'http://'</span>+Gl.URL+<span class="string">'/xxxx'</span> </span><br><span class="line">            <span class="keyword">print</span> url </span><br><span class="line">            result=self.doPost(url, values) </span><br><span class="line">            <span class="keyword">print</span> result </span><br><span class="line">            rdata=json.loads(self.result_decrypt(result)) </span><br><span class="line">            self.checksign(rdata) </span><br><span class="line">    <span class="keyword">if</span> __name__==<span class="string">'__main__</span></span><br></pre></td></tr></table></figure>

<p>知识点：<br>调试代码的时候也遇到了一些小问题和技巧<br>import的时候，如果有同名的类可以起个别名。不然会有报错，告诉这个类找不到某个方法from Crypto.Cipher import PKCS1_v1_5，from Crypto.Signature import PKCS1_v1_5 as pk，这个需要注意一下<br>另外,如果想将字典内的单引号都变为双引号，可以用json.dumps方法</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Wenng</span>
                    </p>
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Python/"># Python</a>
                    
                        <a href="/tags/加密/"># 加密</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/07/21/a-id-36/">频繁的安装和卸载app会不会伤害苹果手机？</a>
            
            
            <a class="next" rel="next" href="/2018/06/09/a-id-45/">在Mac上配置rails开发环境</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Wenng | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
