<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>如何给老婆解释什么是RPC | 张卫宁的技术博客</title>



    <link rel="icon" href="/cat.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">weining&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/E-BOOK">E-BOOK</a>
                
                    <a class="menu-item" href="http://deceptivestarry.gitee.io/finddata">Search</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">weining&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/E-BOOK">E-BOOK</a>
                
                    <a class="menu-item" href="http://deceptivestarry.gitee.io/finddata">Search</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">如何给老婆解释什么是RPC</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Wenng</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 27, 2019&nbsp;&nbsp;15:12:32</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>一个阳光明媚的早晨，老婆又在翻看我订阅的技术杂志。</p>
<p>“老公，什么是RPC呀，为什么你们程序员那么多黑话！”，老婆还是一如既往的好奇。<br>“RPC，就是<strong>Remote Procedure Call</strong>的简称呀，翻译成中文就是<strong>远程过程调用</strong>嘛”，我一边看着书，一边漫不经心的回答着。<br>“啥？你在说啥？谁不知道翻译成中文是什么意思？你个废柴，快给我滚去洗碗！”<br>“我去。。。”，我如梦初醒，我对面坐着的可不是一个程序员，为了不去洗碗，我瞬间调动起全部脑细胞，星辰大海在我脑中汇聚，灵感涌现……</p>
<p>“是这样，远程过程调用，自然是相对于本地过程调用来说的嘛。”<br>“嗯哼，那先给老娘讲讲，本地过程调用是啥子？”<br>“本地过程调用，就好比你现在在家里，你要想洗碗，那你直接把碗放进洗碗机，打开洗碗机开关就可以洗了。这就叫本地过程调用。”</p>
<p>“哎呦，我可不干，那啥是远程过程调用？”<br>“远程嘛，那就是你现在不在家，跟姐妹们浪去了，突然发现碗还没洗，打了个电话过来，叫我去洗碗，这就是远程过程调用啦”，多么通俗易懂的解释，我真是天才！</p>
<p>“哦！我明白了”，说着，老婆开始收拾包包。<br>“你这是干啥去哦”<br>“我？我要出门浪去呀，待会记得接收我的远程调用哦，哦不，咱们要专业点，应该说，待会记得接收我的RPC哦！”</p>
<p>……</p>
<blockquote>
<p>非程序员请就此止步，程序员请继续往前走……</p>
</blockquote>
<img src="/2019/09/27/2014如何向外行解释RPC/7143349-b927e065a62740f2.webp">

<h1 id="如何科学的解释RPC"><a href="#如何科学的解释RPC" class="headerlink" title="如何科学的解释RPC"></a>如何科学的解释RPC</h1><p>说起RPC，就不能不提到<strong>分布式</strong>，这个促使RPC诞生的领域。</p>
<p>假设你有一个计算器接口，Calculator，以及它的实现类CalculatorImpl，那么在系统还是<strong>单体应用</strong>时，你要调用Calculator的add方法来执行一个加运算，直接new一个CalculatorImpl，然后调用add方法就行了，这其实就是非常普通的<strong>本地函数调用</strong>，因为在<strong>同一个地址空间</strong>，或者说在同一块内存，所以通过方法栈和参数栈就可以实现。</p>
  <img src="/2019/09/27/2014如何向外行解释RPC/7143349-443a8cbcf6136ef5.webp">

<p>现在，基于高性能和高可靠等因素的考虑，你决定将系统改造为分布式应用，将很多可以共享的功能都单独拎出来，比如上面说到的计算器，你单独把它放到一个服务里头，让别的服务去调用它。</p>
<img src="/2019/09/27/2014如何向外行解释RPC/7143349-9b1fbd80b8db018b.webp">

<p>这下问题来了，服务A里头并没有CalculatorImpl这个类，那它要怎样调用服务B的CalculatorImpl的add方法呢？</p>
<p>有同学会说，可以模仿B/S架构的调用方式呀，在B服务暴露一个Restful接口，然后A服务通过调用这个Restful接口来间接调用CalculatorImpl的add方法。</p>
<p>很好，这已经很接近RPC了，不过如果是这样，那每次调用时，是不是都需要写一串发起http请求的代码呢？比如httpClient.sendRequest…之类的，能不能像本地调用一样，去发起远程调用，让使用者感知不到远程调用的过程呢，像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span></span><br><span class="line">private Calculator calculator;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">calculator.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候，有同学就会说，用<strong>代理模式</strong>呀！而且最好是结合Spring IoC一起使用，通过Spring注入calculator对象，注入时，如果扫描到对象加了@Reference注解，那么就给它生成一个代理对象，将这个代理对象放进容器中。而这个代理对象的内部，就是通过httpClient来实现RPC远程过程调用的。</p>
<p>可能上面这段描述比较抽象，不过这就是很多RPC框架要解决的问题和解决的思路，比如阿里的Dubbo。</p>
<p>总结一下，<strong>RPC要解决的两个问题：</strong></p>
<ol>
<li><strong>解决分布式系统中，服务之间的调用问题。</strong></li>
<li><strong>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</strong></li>
</ol>
<h1 id="如何实现一个RPC"><a href="#如何实现一个RPC" class="headerlink" title="如何实现一个RPC"></a>如何实现一个RPC</h1><p>实际情况下，RPC很少用到http协议来进行数据传输，毕竟我只是想传输一下数据而已，何必动用到一个文本传输的应用层协议呢，我为什么不直接使用<strong>二进制传输</strong>？比如直接用Java的Socket协议进行传输？</p>
<p>不管你用何种协议进行数据传输，<strong>一个完整的RPC过程，都可以用下面这张图来描述</strong>：</p>
<img src="/2019/09/27/2014如何向外行解释RPC/7143349-9e00bb104b9e3867.webp">


<p>以左边的Client端为例，Application就是rpc的调用方，Client Stub就是我们上面说到的代理对象，也就是那个看起来像是Calculator的实现类，其实内部是通过rpc方式来进行远程调用的代理对象，至于Client Run-time Library，则是实现远程调用的工具包，比如jdk的Socket，最后通过底层网络实现实现数据的传输。</p>
<p>这个过程中最重要的就是<strong>序列化</strong>和<strong>反序列化</strong>了，因为数据传输的数据包必须是二进制的，你直接丢一个Java对象过去，人家可不认识，你必须把Java对象序列化为二进制格式，传给Server端，Server端接收到之后，再反序列化为Java对象。</p>
<p>下一次我也将通过代码，给大家演示一下，如何实现一个简单的RPC。</p>
<h1 id="RPC-vs-Restful"><a href="#RPC-vs-Restful" class="headerlink" title="RPC vs Restful"></a>RPC vs Restful</h1><p>其实这两者并不是一个维度的概念，总得来说RPC涉及的维度更广。</p>
<p>如果硬要比较，那么可以从RPC风格的url和Restful风格的url上进行比较。</p>
<p>比如你提供一个查询订单的接口，用RPC风格，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/queryOrder?orderId=123</span><br></pre></td></tr></table></figure>

<p>用Restful风格呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get  </span><br><span class="line">/order?orderId=123</span><br></pre></td></tr></table></figure>

<p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p>
<h1 id="RPC-vs-RMI"><a href="#RPC-vs-RMI" class="headerlink" title="RPC vs RMI"></a>RPC vs RMI</h1><p>严格来说这两者也不是一个维度的。</p>
<p>RMI是Java提供的一种访问远程对象的协议，是已经实现好了的，可以直接用了。</p>
<p>而RPC呢？人家只是一种编程模型，并没有规定你具体要怎样实现，<strong>你甚至都可以在你的RPC框架里面使用RMI来实现数据的传输</strong>，比如Dubbo：<a href="https://link.jianshu.com/?t=http%3A%2F%2Fdubbo.apache.org%2Fbooks%2Fdubbo-user-book%2Freferences%2Fprotocol%2Frmi.html" target="_blank" rel="noopener">Dubbo - rmi协议</a></p>
<h1 id="RPC没那么简单"><a href="#RPC没那么简单" class="headerlink" title="RPC没那么简单"></a>RPC没那么简单</h1><p><strong>要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架。</strong></p>
<p>比如，既然是分布式了，那么一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？</p>
<p>这时候就需要一个服务注册中心，比如在Dubbo里头，就可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用。</p>
<p>那么选哪个调用好呢？这时候就需要负载均衡了，于是你又得考虑如何实现复杂均衡，比如Dubbo就提供了好几种负载均衡策略。</p>
<p>这还没完，总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题，blablabla……</p>
<p>你以为就这样结束了，没呢，还有这些：</p>
<ul>
<li>客户端总不能每次调用完都干等着服务端返回数据吧，于是就要支持异步调用；</li>
<li>服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li>
<li>服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li>
<li>服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li>
<li>……</li>
</ul>
<p>如此种种，都是一个优秀的RPC框架需要考虑的问题。</p>
<p>当然，接下来我们还是先实现一个简单的RPC，再在上面一步步优化！</p>
<p>传送门： <a href="https://www.jianshu.com/p/5b90a4e70783" target="_blank" rel="noopener">如何实现一个简单的RPC</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://link.jianshu.com/?t=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRemote_procedure_call" target="_blank" rel="noopener">wikipedia - RPC</a></li>
<li><a href="https://link.jianshu.com/?t=https%3A%2F%2Fsites.google.com%2Fsite%2Fwagingguerillasoftware%2Frest-series%2Fwhat-is-restful-rest-vs-rpc" target="_blank" rel="noopener">what-is-restful-rest-vs-rpc</a></li>
<li><a href="https://link.jianshu.com/?t=https%3A%2F%2Ftechdifferences.com%2Fdifference-between-rpc-and-rmi.html" target="_blank" rel="noopener">difference-between-rpc-and-rmi.html</a></li>
<li><a href="https://link.jianshu.com/?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2728495%2Fwhat-is-the-difference-between-java-rmi-and-rpc" target="_blank" rel="noopener">what-is-the-difference-between-java-rmi-and-rpc</a></li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fdubbo.apache.org%2Fbooks%2Fdubbo-user-book%2F" target="_blank" rel="noopener">Dubbo 使用文档</a></li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fdubbo.apache.org%2Fbooks%2Fdubbo-dev-book%2F" target="_blank" rel="noopener">Dubbo 源码开发手册</a></li>
<li>一本很棒的分布式书籍：《大型网站系统与Java中间件实践》</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Wenng</span>
                    </p>
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/10/07/2015docker常用命令/">Docker常用命令</a>
            
            
            <a class="next" rel="next" href="/2019/09/25/2013不得不服的著名定律/">经济学/社会学/心理学著名定律/效应</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Wenng | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
